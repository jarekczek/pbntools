# HG changeset patch
# Parent 7b9e4837c7b98c41cc4dd274c7b8e043769e4249

diff -r 7b9e4837c7b9 zbar/convert.c
--- a/zbar/convert.c	Sat Mar 24 16:41:52 2012 +0100
+++ b/zbar/convert.c	Mon Mar 26 18:24:07 2012 +0200
@@ -1153,8 +1153,8 @@
         if(min_cost > cost) {
             min_cost = cost;
             min_fmt = *fmt;
-            if(!cost)
-                break;
+//BS            // if(!cost)
+                // break;
         }
     }
     if(win)
diff -r 7b9e4837c7b9 zbar/video/vfw.c
--- a/zbar/video/vfw.c	Sat Mar 24 16:41:52 2012 +0100
+++ b/zbar/video/vfw.c	Mon Mar 26 18:24:07 2012 +0200
@@ -4,7 +4,7 @@
  *  This file is part of the ZBar Bar Code Reader.
  *
  *  The ZBar Bar Code Reader is free software; you can redistribute it
- *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  and/or modify it ugnder the terms of the GNU Lesser Public License as
  *  published by the Free Software Foundation; either version 2.1 of
  *  the License, or (at your option) any later version.
  *
@@ -37,6 +37,10 @@
         (bih)->biXPelsPerMeter, (bih)->biYPelsPerMeter,                 \
         (bih)->biClrImportant, (bih)->biClrUsed, (bih)->biSize
 
+// taken from Capturing an Image winapi sample
+#define BMP_SIZE(cx, cy, bitsPerPix) \
+        ((((cx) * (bitsPerPix) + 31) / 32) * 4 * (cy))
+
 struct video_state_s {
     zbar_thread_t thread;       /* capture message pump */
     HANDLE captured;
@@ -45,8 +49,16 @@
     int bi_size;                /* size of bih */
     BITMAPINFOHEADER *bih;      /* video format details */
     zbar_image_t *image;        /* currently capturing frame */
+    void *decompImg;              ///< decompressed image data, in rgb3
+    HDRAWDIB hdd;
+    HDC hdcMem;                 ///< dc to decompress image to
+    HBITMAP hbmpMem;            ///< a bitmap to decompress image to
+    BITMAPINFOHEADER bihDecomp; /**< decompressed bitmap info */
 };
 
+/** A format into which all captured frames will be decompressed. */
+static const uint32_t vfw_common_fmt = fourcc('B','G','R','3');
+
 static const uint32_t vfw_formats[] = {
     /* planar YUV formats */
     fourcc('I','4','2','0'),
@@ -63,6 +75,7 @@
     /* FIXME AYUV? Y411? Y41P? */
 
     /* packed rgb formats */
+    fourcc('R','G','B','O'),
     fourcc('B','G','R','3'),
     fourcc('B','G','R','4'),
 
@@ -120,6 +133,127 @@
     return(0);
 }
 
+/// Initialization of windows decompression environment.
+/// vdo->state->bih must be already initialized.
+static int win_decomp_image_init(zbar_video_t *vdo)
+{
+    video_state_t *s = vdo->state;
+    BITMAPINFOHEADER *bih = vdo->state->bih;
+    long cx = bih->biWidth;
+    long cy = bih->biHeight;
+    
+    HDC hdc = GetDC(NULL);
+    if (!hdc) { return(err_capture(vdo, SEV_ERROR,
+                               ZBAR_ERR_WINAPI, __func__,
+                               "GetDC")); }
+    vdo->state->hdcMem = CreateCompatibleDC(hdc);
+    if (!vdo->state->hdcMem) { return(err_capture(vdo, SEV_ERROR,
+                               ZBAR_ERR_WINAPI, __func__,
+                               "CreateCompatibleDC")); }
+    s->hbmpMem = CreateCompatibleBitmap(hdc, cx, cy);
+    if (!s->hbmpMem) { return(err_capture(vdo, SEV_ERROR,
+                               ZBAR_ERR_WINAPI, __func__,
+                               "CreateCompatibleBitmap")); }
+    if ( !ReleaseDC(s->hwnd, hdc)) {
+      err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                            "ReleaseDC");
+    }
+    SelectObject(s->hdcMem, s->hbmpMem);
+    if (GetLastError() != 0) { return(err_capture(vdo, SEV_ERROR,
+                                      ZBAR_ERR_WINAPI, __func__,
+                                      "SelectObject(hbmpMem)")); }
+    vdo->state->hdd = DrawDibOpen();
+    if (!vdo->state->hdd) { return(err_capture(vdo, SEV_ERROR,
+                            ZBAR_ERR_WINAPI, __func__,
+                            "DrawDibOpen")); }
+
+    memset(&s->bihDecomp, 0, sizeof(s->bihDecomp));
+    s->bihDecomp.biSize = sizeof(s->bihDecomp);
+    s->bihDecomp.biWidth = cx;
+    s->bihDecomp.biHeight = -cy; // top to bottom bitmap
+    s->bihDecomp.biPlanes = 1;
+    // settings here must be compatible with vfw_common_fmt
+    s->bihDecomp.biBitCount = 24;
+    s->bihDecomp.biCompression = BI_RGB;
+
+    if (!s->decompImg) {
+        s->decompImg = malloc(BMP_SIZE(cx, cy, s->bihDecomp.biBitCount));
+        if (!s->decompImg) { return -1; }
+    }
+
+    return 0;
+}
+
+/// Decompresses image from camera format to common windows format
+/// vfw_common_fmt
+static void win_decomp_image(zbar_video_t *vdo)
+{
+    video_state_t *s = vdo->state;
+    zbar_image_t *img = vdo->state->image;
+    BITMAPINFOHEADER *bih = vdo->state->bih;
+    long cx = bih->biWidth;
+    long cy = bih->biHeight;
+    int ok;
+    //BITMAP bmp;
+
+    if (!img) { return; }
+    if (!vdo->state->decompImg) { return; }
+    if (!s->hdd || !s->hdcMem || !s->hbmpMem) { return; }
+
+    ok = DrawDibBegin(s->hdd, s->hdcMem, -1, -1,
+                      (BITMAPINFOHEADER*)bih, cx, cy, 0);
+    if (!ok) { err_capture(vdo, SEV_ERROR, ZBAR_ERR_INTERNAL, __func__,
+                           "DrawDibBegin");
+               goto not_ok;
+    }
+
+    ok = DrawDibDraw(s->hdd, s->hdcMem, 0,0, cx,cy, bih, (LPVOID)img->data, 
+                     0,0, cx,cy, DDF_SAME_DRAW);
+    if (!ok) { err_capture(vdo, SEV_ERROR, ZBAR_ERR_INTERNAL, __func__,
+                           "DrawDibDraw");
+    }
+
+    ok = DrawDibEnd(vdo->state->hdd);
+    if (!ok) { err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                           "DrawDibEnd");
+               goto not_ok;
+    }
+
+    ok = ( 0 != GetDIBits(s->hdcMem, s->hbmpMem, 0, cy, s->decompImg,
+                          (BITMAPINFO*)&s->bihDecomp, DIB_RGB_COLORS));
+    if (!ok) { err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                           "GetDIBits");
+               goto not_ok;
+    }
+
+    not_ok:
+    img->data = vdo->state->decompImg;
+    img->datalen = BMP_SIZE(cx, cy, s->bihDecomp.biBitCount);
+}
+
+/// Cleanup of windows decompression environment.
+static void win_decomp_image_cleanup(zbar_video_t *vdo)
+{
+    video_state_t *s = vdo->state;
+
+    if (vdo->state->hdd && !DrawDibClose(vdo->state->hdd)) {
+      err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                            "DrawDibClose");
+    }
+    if (s->hdcMem && !DeleteDC(s->hdcMem)) {
+      err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                            "DeleteDC on hdcMem");
+    }
+    if (s->hbmpMem && !DeleteObject(s->hbmpMem)) {
+      err_capture(vdo, SEV_ERROR, ZBAR_ERR_WINAPI, __func__,
+                            "DeleteObject on hbmpMem");
+    }
+    if (s->decompImg) {
+        free(s->decompImg);
+        s->decompImg = NULL;
+    }
+}
+
 static LRESULT CALLBACK vfw_stream_cb (HWND hwnd,
                                        VIDEOHDR *hdr)
 {
@@ -137,6 +271,7 @@
         img->data = hdr->lpData;
         img->datalen = hdr->dwBufferLength;
         vdo->state->image = img;
+        win_decomp_image(vdo);
         SetEvent(vdo->state->captured);
     }
     _zbar_mutex_unlock(&vdo->qlock);
@@ -214,6 +349,7 @@
     return(0);
 }
 
+/// @param fmt equal to vfw_common_fmt
 static int vfw_set_format (zbar_video_t *vdo,
                            uint32_t fmt)
 {
@@ -224,48 +360,31 @@
 
     BITMAPINFOHEADER *bih = vdo->state->bih;
     assert(bih);
+
+    if(!capGetVideoFormat(vdo->state->hwnd, bih, vdo->state->bi_size))
+        return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
+                           "getting video format"));
+
     bih->biWidth = vdo->width;
     bih->biHeight = vdo->height;
-    switch(fmtdef->group) {
-    case ZBAR_FMT_GRAY:
-        bih->biBitCount = 8;
-        break;
-    case ZBAR_FMT_YUV_PLANAR:
-    case ZBAR_FMT_YUV_PACKED:
-    case ZBAR_FMT_YUV_NV:
-        bih->biBitCount = 8 + (16 >> (fmtdef->p.yuv.xsub2 + fmtdef->p.yuv.ysub2));
-        break;
-    case ZBAR_FMT_RGB_PACKED:
-        bih->biBitCount = fmtdef->p.rgb.bpp * 8;
-        break;
-    default:
-        bih->biBitCount = 0;
-    }
-    bih->biClrUsed = bih->biClrImportant = 0;
-    bih->biCompression = fmt;
 
-    zprintf(8, "seting format: %.4s(%08x) " BIH_FMT "\n",
-            (char*)&fmt, fmt, BIH_FIELDS(bih));
+    // We set the same format as it was before. We don't care about
+    // the format, because we will make windows decompress it to
+    // vfw_common_fmt
 
     if(!capSetVideoFormat(vdo->state->hwnd, bih, vdo->state->bi_size))
         return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
                            "setting video format"));
 
-    if(!capGetVideoFormat(vdo->state->hwnd, bih, vdo->state->bi_size))
-        return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
-                           "getting video format"));
-
-    if(bih->biCompression != fmt)
-        return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
-                           "video format set ignored"));
-
+    // vdo->format will store our common format - vfw_common_fmt
+    // the real hardware format will be stored as bih->biCompression
     vdo->format = fmt;
     vdo->width = bih->biWidth;
     vdo->height = bih->biHeight;
     vdo->datalen = bih->biSizeImage;
 
-    zprintf(4, "set new format: %.4s(%08x) " BIH_FMT "\n",
-            (char*)&fmt, fmt, BIH_FIELDS(bih));
+    zprintf(4, "set new format: %.4s(%08lx) " BIH_FMT "\n",
+            (char*)&bih->biCompression, bih->biCompression, BIH_FIELDS(bih));
     return(0);
 }
 
@@ -274,6 +393,7 @@
 {
     if(vfw_set_format(vdo, fmt))
         return(-1);
+    if (win_decomp_image_init(vdo) != 0) { return -1; }
 
     HWND hwnd = vdo->state->hwnd;
     CAPTUREPARMS cp;
@@ -354,56 +474,12 @@
         CloseHandle(state->captured);
         state->captured = NULL;
     }
+
+    win_decomp_image_cleanup(vdo);
+
     return(0);
 }
 
-static int vfw_probe_format (zbar_video_t *vdo,
-                             uint32_t fmt)
-{
-    const zbar_format_def_t *fmtdef = _zbar_format_lookup(fmt);
-    if(!fmtdef)
-        return(0);
-
-    zprintf(4, "    trying %.4s(%08x)...\n", (char*)&fmt, fmt);
-    BITMAPINFOHEADER *bih = vdo->state->bih;
-    bih->biWidth = vdo->width;
-    bih->biHeight = vdo->height;
-    switch(fmtdef->group) {
-    case ZBAR_FMT_GRAY:
-        bih->biBitCount = 8;
-        break;
-    case ZBAR_FMT_YUV_PLANAR:
-    case ZBAR_FMT_YUV_PACKED:
-    case ZBAR_FMT_YUV_NV:
-        bih->biBitCount = 8 + (16 >> (fmtdef->p.yuv.xsub2 + fmtdef->p.yuv.ysub2));
-        break;
-    case ZBAR_FMT_RGB_PACKED:
-        bih->biBitCount = fmtdef->p.rgb.bpp * 8;
-        break;
-    default:
-        bih->biBitCount = 0;
-    }
-    bih->biCompression = fmt;
-
-    if(!capSetVideoFormat(vdo->state->hwnd, bih, vdo->state->bi_size)) {
-        zprintf(4, "\tno (set fails)\n");
-        return(0);
-    }
-
-    if(!capGetVideoFormat(vdo->state->hwnd, bih, vdo->state->bi_size))
-        return(0/*FIXME error...*/);
-
-    zprintf(6, "\tactual: " BIH_FMT "\n", BIH_FIELDS(bih));
-
-    if(bih->biCompression != fmt) {
-        zprintf(4, "\tno (set ignored)\n");
-        return(0);
-    }
-
-    zprintf(4, "\tyes\n");
-    return(1);
-}
-
 static int vfw_probe (zbar_video_t *vdo)
 {
     video_state_t *state = vdo->state;
@@ -426,16 +502,8 @@
     }
     vdo->datalen = bih->biSizeImage;
 
-    zprintf(2, "probing supported formats:\n");
-    vdo->formats = calloc(VFW_NUM_FORMATS, sizeof(uint32_t));
-
-    int n = 0;
-    const uint32_t *fmt;
-    for(fmt = vfw_formats; *fmt; fmt++)
-        if(vfw_probe_format(vdo, *fmt))
-            vdo->formats[n++] = *fmt;
-
-    vdo->formats = realloc(vdo->formats, (n + 1) * sizeof(uint32_t));
+    vdo->formats = calloc(2, sizeof(uint32_t));
+    vdo->formats[0] = vfw_common_fmt;
 
     vdo->width = bih->biWidth;
     vdo->height = bih->biHeight;
